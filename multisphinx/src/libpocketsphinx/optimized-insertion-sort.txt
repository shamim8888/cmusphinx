Insertion sort should be relatively efficient for sorting the
backpointer table since it contains long runs of the same value and is
loosely ordered.

We can speed it up by speeding up the search for an insertion location
- we track the oldest backpointer in the lexicon tree and its
corresponding location in the backpointer table, and there is no need
to search before it for insertion.  This also has the consequence that
all backpointer entries before it are frozen in place and can thus be
converted to lattice nodes or used for fwdflat search.

This gives us one version of the elastic lookahead window.  The other
version uses the "convergence" property of the lattice, which is
defined hence:

---

So we will add another phase to each frame of search, which is sorting
and garbage collection of the lattice (in the future we can hopefully
put this in its own thread) This task gets inserted between fwdflat
and fwdtree, and between fwdtree and bestpath/lattice generation.

---

The problem with this is that when you permute the backpointer table,
you have to rewrite all the references to those backpointers.  This is
one place where the oldest backpointer thing can help - we know that
no new entries will be generated that point to things behind it, so we
are free to reorder everything from it on backwards.  Then we just
have to snap the pointers as part of the insertion operation.

It also means that we can sort everything between the previous oldest
backpointer and the latest one without having to touch anything in the
more distant past, since nothing will point any further back.

I.e. we just insertion sort within variably-sized blocks.

---

We divide the backpointer table into two parts - the oldest part sorts
by start time (needed to do fwdflat search and build word lattice)
while the newest part sorts by end time (needed by fwdtree search).
The ending frame of the oldest active backpointer in the search tree
is the dividing line between the two.

The end-time sorted part constitutes an elastic window within which
phoneme lookahead, fwdtree, and potentially other forward searches (or
parallel ones) operate.

Behind the dividing line is a fixed window in which fwdflat operates.

Behind that, backpointer entries are retired or garbage collected by
the lattice generator.

---

To reduce the length of the elastic window, forcibly break long
silences - if the oldest backpointer in a silence word is too old,
clear its path scores and re-enter it.

Note that if the threshold is too small this can cause errors at the
beginning of the sentence - not sure why this happens (something to do
with scores i guess) but it should be fixable somehow.
