
fwdflat sliding window

 * Need to be able to traverse/index backpointer table by start frame
 * I think this might be useful for garbage collection too
 * Seems like we ultimately need multiple "views" over the backpointer table
   - indexes really, so that multiple passes can access it simultaneously

 * Actually what we can do is just refresh the expand word list
   expiring entries with start frames outside the window and adding new ones

 * Alternately we could just sort the backpointer table according to start frame
   How efficient/inefficient is it to do this incrementally in fwdflat?

Potential idea:

 * Track oldest backpointer in lexicon tree
   - once it passes frame K, no more words can start in that frame
   - therefore we can reorder the bptbl up to frame K
   - the bptbl is *mostly* sorted, so qsort is a Bad Idea
   - actually we should just heapify it, it is really a priority queue
     which fwdtree feeds and fwdflat and lattice generation pull from
   - actually the decoding pipeline is in fact one big priority queue
     or rather two+ of them chained together
 * So what we can do is just change the backpointer insertion function
   to heapify things
 * The problem with this is that since it's mostly sorted we could do
   much better than O(n log n) to sort it, but that's what heapsort
   gives us
 * So a modified insertion sort seems like the right way to do this

Track the number of inversions in the backpointer table to determine
the best algorithm

Damerau-Levenshtein distance

Make fwdflat work without word_lat_idx

bptr garbage collection

Refactoring:

1) split backpointer table / score stack from ngram search
2) make fwdflat overwrite backpointer table rather than clear it

Insertion sort should be relatively efficient for sorting the
backpointer table since it contains long runs of the same value and is
loosely ordered.

We can speed it up by speeding up the search for an insertion location
- we track the oldest backpointer in the lexicon tree and its
corresponding location in the backpointer table, and there is no need
to search before it for insertion.  This also has the consequence that
all backpointer entries before it are frozen in place and can thus be
converted to lattice nodes or used for fwdflat search.

This gives us one version of the elastic lookahead window.  The other
version uses the "convergence" property of the lattice, which is
defined hence:

---

So we will add another phase to each frame of search, which is sorting
and garbage collection of the lattice (in the future we can hopefully
put this in its own thread) This task gets inserted between fwdflat
and fwdtree, and between fwdtree and bestpath/lattice generation.

---

The problem with this is that when you permute the backpointer table,
you have to rewrite all the references to those backpointers.  This is
one place where the oldest backpointer thing can help - we know that
no new entries will be generated that point to things behind it, so we
are free to reorder everything from it on backwards.  Then we just
have to snap the pointers as part of the insertion operation.

It also means that we can sort everything between the previous oldest
backpointer and the latest one without having to touch anything in the
more distant past, since nothing will point any further back.

I.e. we just insertion sort within variably-sized blocks.

---

We divide the backpointer table into two parts - the oldest part sorts
by start time (needed to do fwdflat search and build word lattice)
while the newest part sorts by end time (needed by fwdtree search).
The ending frame of the oldest active backpointer in the search tree
is the dividing line between the two.

The end-time sorted part constitutes an elastic window within which
phoneme lookahead, fwdtree, and potentially other forward searches (or
parallel ones) operate.

Behind the dividing line is a fixed window in which fwdflat operates.

Behind that, backpointer entries are retired or garbage collected by
the lattice generator.

---

To reduce the length of the elastic window, forcibly break long
silences - if the oldest backpointer in a silence word is too old,
clear its path scores and re-enter it.

Note that if the threshold is too small this can cause errors at the
beginning of the sentence - not sure why this happens (something to do
with scores i guess) but it should be fixable somehow.

---

Garbage collection is essentially useless.  This is because the
forward lattice is a tree, therefore the set of coaccessible states
from the from the final state is actually just the best path.

However, the points at which the oldest backpointer jumps might be
useful convergence points - need to think a bit more about what they
represent, and do some experiments.

Basically the right thing to do for now is to run the lattice
generation pass in a pipeline with the other passes, and retire
backpointer entries after they're processed by it.

We should however apply the bogus algorithm to see how much we can
remove.  It can work incrementally since the existence of an active
backpointer im that frame implies that it will have a successor.
