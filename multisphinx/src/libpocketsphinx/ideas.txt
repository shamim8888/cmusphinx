
fwdflat sliding window

 * Need to be able to traverse/index backpointer table by start frame
 * I think this might be useful for garbage collection too
 * Seems like we ultimately need multiple "views" over the backpointer table
   - indexes really, so that multiple passes can access it simultaneously

 * Actually what we can do is just refresh the expand word list
   expiring entries with start frames outside the window and adding new ones

 * Alternately we could just sort the backpointer table according to start frame
   How efficient/inefficient is it to do this incrementally in fwdflat?

Potential idea:

 * Track oldest backpointer in lexicon tree
   - once it passes frame K, no more words can start in that frame
   - therefore we can reorder the bptbl up to frame K
   - the bptbl is *mostly* sorted, so qsort is a Bad Idea
   - actually we should just heapify it, it is really a priority queue
     which fwdtree feeds and fwdflat and lattice generation pull from
   - actually the decoding pipeline is in fact one big priority queue
     or rather two+ of them chained together
 * So what we can do is just change the backpointer insertion function
   to heapify things
 * The problem with this is that since it's mostly sorted we could do
   much better than O(n log n) to sort it, but that's what heapsort
   gives us
 * So a modified insertion sort seems like the right way to do this

Track the number of inversions in the backpointer table to determine
the best algorithm

Damerau-Levenshtein distance

Make fwdflat work without word_lat_idx

bptr garbage collection

Refactoring:

1) split backpointer table / score stack from ngram search
2) make fwdflat overwrite backpointer table rather than clear it

Insertion sort should be relatively efficient for sorting the
backpointer table since it contains long runs of the same value and is
loosely ordered.

We can speed it up by speeding up the search for an insertion location
- we track the oldest backpointer in the lexicon tree and its
corresponding location in the backpointer table, and there is no need
to search before it for insertion.  This also has the consequence that
all backpointer entries before it are frozen in place and can thus be
converted to lattice nodes or used for fwdflat search.

This gives us one version of the elastic lookahead window.  The other
version uses the "convergence" property of the lattice, which is
defined hence:

---

So we will add another phase to each frame of search, which is sorting
and garbage collection of the lattice (in the future we can hopefully
put this in its own thread) This task gets inserted between fwdflat
and fwdtree, and between fwdtree and bestpath/lattice generation.

---

The problem with this is that when you permute the backpointer table,
you have to rewrite all the references to those backpointers.  This is
one place where the oldest backpointer thing can help - we know that
no new entries will be generated that point to things behind it, so we
are free to reorder everything from it on backwards.  Then we just
have to snap the pointers as part of the insertion operation.

It also means that we can sort everything between the previous oldest
backpointer and the latest one without having to touch anything in the
more distant past, since nothing will point any further back.

I.e. we just insertion sort within variably-sized blocks.

---

We divide the backpointer table into two parts - the oldest part sorts
by start time (needed to do fwdflat search and build word lattice)
while the newest part sorts by end time (needed by fwdtree search).
The ending frame of the oldest active backpointer in the search tree
is the dividing line between the two.

The end-time sorted part constitutes an elastic window within which
phoneme lookahead, fwdtree, and potentially other forward searches (or
parallel ones) operate.

Behind the dividing line is a fixed window in which fwdflat operates.

Behind that, backpointer entries are retired or garbage collected by
the lattice generator.

---

To reduce the length of the elastic window, forcibly break long
silences - if the oldest backpointer in a silence word is too old,
clear its path scores and re-enter it.

Note that if the threshold is too small this can cause errors at the
beginning of the sentence - not sure why this happens (something to do
with scores i guess) but it should be fixable somehow.

---

In practice when we garbage collect the bp table, we obtain a compact
portion followed by a growing gap, then the elastic 'scratchpad'
window.  The backpointer indices before the gap grow much slower than
the ones after it, and can be reassigned as necessary.

We would like to separate these two parts of the bptbl, and use a
rotating buffer for the working window with an expandable vector (or
even a tree) for the compact, static portion.

Also we want the infinitely growable parts such as ef_idx and permute
to, well, not be infinitely growable, instead having a base index that
corresponds to their respective region of applicability.

Another important question is, how important is it to have sequential,
numeric backpointer IDs that directly correspond to memory locations?
If looking up backpointers is not particularly frequent then we could
add a layer of indirection between them and the actual backpointer
table, at which point there is no longer any need to compact it - we
can just use a freelist to allocate new backpointers as needed.

---

ngram_search_exit_score gets called A LOT.  Not sure what to do about
that.
